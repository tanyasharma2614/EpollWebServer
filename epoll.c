/* Demo web server in C. Code auto-generated by chatGPT in
 * March 2023. Credit goes to all the authors posting demo
 * web server C code on the Internet.  Requires a Linux
 * environment due to socket options. Tested on Ubuntu 22.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include<sys/epoll.h>

#define PORT 8080
#define RESPONSE "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\nHello, world!\r\n"
#define MAX_EVENTS 10

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int opt = 1;
    int addrlen = sizeof(address);
    char buffer[1024] = {0};

    // create socket file descriptor
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // set socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt failed");
        exit(EXIT_FAILURE);
    }

    // bind socket to port 8080
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // listen for incoming connections
    if (listen(server_fd, 200) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }


    //creating an epoll instance with default behavior 
    int epoll_fd=epoll_create1(0);
    if(epoll_fd==-1){
        perror("epoll instance creation failed");
        exit(EXIT_FAILURE);
    }
    
    //we now add the listening socket to our epoll instance to monitor incoming connection requests using the EPOLLIN flag
    struct epoll_event event;
    event.data.fd = server_fd;
    event.events=EPOLLIN;

    /*We are changing the epoll instance's monitoring settings by adding a file descriptor to the epoll instance by using EPOLL_CTL_ADD and then adding the server_fd to epoll_fd and monitoring the epoll event 'event'*/
    if(epoll_ctl(epoll_fd,EPOLL_CTL_ADD,server_fd,&event)==-1){
        perror("Adding listening socket to epoll instance failed");
        exit(EXIT_FAILURE);
    }

    //we reprogram the event loop
    struct epoll_event events[MAX_EVENTS];
    while(1){

        //waiting till some event occurs on the epoll instance and if we timeout the value returned will be -1 or else will return number of events that have occurred 
        int num_events=epoll_wait(epoll_fd,events,MAX_EVENTS,-1);
        if(num_events==-1){
            perror("Epoll wait has timed out, no events have occurred");
            exit(EXIT_FAILURE);
        }

        //iterating through every event occurred in events and checking if its the same as the server_fd listening socket
        for(int i=0;i<num_events;i++){

            //if true, the client connection can be accepted and we store the client socket in new_socket
            if(events[i].data.fd==server_fd){

                //accepting the incoming connection
                if((new_socket=accept(server_fd,(struct sockaddr*)&address, (socklen_t*)&addrlen))<0){
                    perror("Accepting the incoming connection failed");
                    exit(EXIT_FAILURE);
                }

                //now that we have accepted the incoming connection, we can add the client socket to the epoll instance 
                event.data.fd=new_socket;
                event.events=EPOLLIN;
                if(epoll_ctl(epoll_fd,EPOLL_CTL_ADD,new_socket,&event)==-1){
                    perror("Adding the client socket to the epoll instance failed");
                    exit(EXIT_FAILURE);
                }

                 //representing binary representation of the port number as an integer
                printf("Connection accepted from :%d\n",ntohs(address.sin_port));
            }

            //handle the incoming data
            else{
                int fd=events[i].data.fd;
                read(fd,buffer,1024);
                printf("%s\n",buffer);
                write(fd,RESPONSE,strlen(RESPONSE));
                close(fd);
            }
        }
    }

    return 0;
}
