/* Demo web server in C. Code auto-generated by chatGPT in
 * March 2023. Credit goes to all the authors posting demo
 * web server C code on the Internet.  Requires a Linux
 * environment due to socket options. Tested on Ubuntu 22.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
//socket programming and network operations
#include <sys/socket.h>
#include <netinet/in.h>
//preprocessor directives, port is the common 8080 port for web servers
//response defines HTTP response message
#define PORT 8080
#define RESPONSE "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\nHello, world!\r\n"

int main() {
    //server socket file descriptor, new_socket is client socket file descripter
    int server_fd, new_socket;
    //contaisn socket address info
    struct sockaddr_in address;
    //socket options
    int opt = 1;
    //sets size of address
    int addrlen = sizeof(address);
    //store data received from client
    char buffer[1024] = {0};

    // create socket file descriptor
    //AF_INET means IPv4 and SOCK_STREAM means we're using TCP, returns newly created file descriptor and saves it to server_fd
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
        perror("socket failed");
        exit(EXIT_FAILURE);
    }

    // set socket options
    //setting socket options for server_fd and SOL_SOCKET means that options apply to socket level, SO_REUSEADDR and SO_REUSEPORT means socket can be resued after it has been shut down allowing fast restart
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT, &opt, sizeof(opt))) {
        perror("setsockopt failed");
        exit(EXIT_FAILURE);
    }

    // bind socket to port 8080
    //ipv4 address
    address.sin_family = AF_INET;
    //accept connections from any network interface
    address.sin_addr.s_addr = INADDR_ANY;
    //port no to bind to and converts port no to network byte order (big endian)
    address.sin_port = htons(PORT);
    //socket can receive incoming connections on port and address specified
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address))<0) {
        perror("bind failed");
        exit(EXIT_FAILURE);
    }

    // listen for incoming connections
    //passive socket, 200 is max queue length for connections
    if (listen(server_fd, 200) < 0) {
        perror("listen failed");
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d\n", PORT);

    while (1) {
        // accept incoming connection
        //establish a new connection
        if ((new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t*)&addrlen))<0) {
            perror("accept failed");
            exit(EXIT_FAILURE);
        }

        // read incoming message
        //stires data in buffer upto 1024 bytes
        read(new_socket, buffer, 1024);
        printf("%s\n", buffer);

        // send response
        //send back http response message
        write(new_socket, RESPONSE, strlen(RESPONSE));
        //close the connection
        close(new_socket);
    }

    return 0;
}
